#
# SPDX-License-Identifier: GPL-2.0-only
#
# Copyright (C) 2015-2020 Micron Technology, Inc.  All rights reserved.
#

The mpool core subsystem provides two primary abstractions to outside callers:

* mblocks
* mlogs

This document speaks mostly of mblocks, but the concepts apply to both mblocks
and mlogs.  Both object types have a struct ecio_layout_descriptor (the
"layout") as their primary in-memory metadata.

A caller gets access to an object either by creating one (e.g. mblock_alloc()),
or by finding an existing object by its objid (e.g. mblock_find_get()).  In
either case, a handle is returned.

In kernel space, a handle is a ref-counted pointer to the layout of the
object.  The object keeps a count of such pointers, so that that the mpcore
subsystem can avoid freeing memory (layouts) that may still be in use.  With
mblocks [and mlogs], it is primarily mblock_delete() that could cause trouble -
since all mpcore metadata is in memory while an mpool is activated.

Object refcounts are not persisted to media.  They just support avoidance
of deleting an object that is still in use.  One good example of this risk
is an mblock which was created by kvdb, and it is possible that for most of
its life, both kvdb and mcache have refs on it.  The scenario we must avoid
is that kvdb deletes the object (e.g. mblock_delete()) while an mcache map
still has a reference on the object.

This might cause you to think in terms of refcount based destructors, but
think again.  Our objects live until deleted, not until the last ref is put.
In fact, it is a bug if kvdb deletes an mblock without first cleaning up all
mcache maps that reference the object.

So the requirement is that object deletion requires that the object refcount
be 1 at the time of deletion.  Note objects are deleted by handle, and if
you have a handle, the refcount had better reflect the existence of that
one valid handle.  If mcache also has a handle, the refcount will be 2.

Get a handle on an mblock

    * mblock_alloc(objid)
    * mblock_realloc(objid)
    * mblock_find_get(objid)

    * mblock_get(handle)     - This is a somewhat special case.  Say you already
		       	       have a handle, and you need to hand off a copy
			       to a thread that will use it for a period
			       and can then release it.  Call mblock_get()
			       for a new refcount on the handle; the thread
			       should call mblock_put() when it is finished
			       with the handle.  Meanwhile, you need to call
			       mblock_put() or mblock_delete() when you are
			       finished (and you are responsible for not
			       calling mblock_delete() before the thread has
			       put its reference...)

Act on an mblock (use a handle)

    * mblock_write(handle)
    * mblock_commit(handle)
    * mblock_read(handle)
    * mblock_get_props(handle) (and variants)

Release a handle on an mblock

    * mblock_put(handle)
    * mblock_delete(handle)
    * mblock_abort(handle)   (prior to commit)

OK, what about user space clients?

Ah, you raise an important issue ;-).  They use mpcore handles, but they also
build some machinary in front of mpcore handles, so that we can clean up
correctly if a user process cores.

See ../mpctl/uhandles-and-refs.txt for details.

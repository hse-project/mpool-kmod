// SPDX-License-Identifier: GPL-2.0-only
/*
 * Copyright (C) 2015-2020 Micron Technology, Inc.  All rights reserved.
 */

/* DOC: Module info.
 *
 * Pool metadata upgrade module.
 *
 * Defines functions used to upgrade the mpool metadata.
 *
 */

#include "mpcore_defs.h"

/*
 * Latest mpool MDC content version understood by this binary.
 * Also version used to write MDC content by this binary.
 */
#define MDCCVER_MAJOR 1
#define MDCCVER_MINOR 0
#define MDCCVER_PATCH 0
#define MDCCVER_DEV   0

/**
 * struct mdccver_info - mpool MDC content version and its information.
 *
 * Such a structure instance is added each time the mpool MDCs content
 * semantic/format changes (making it incompatible with earlier binary
 * versions).
 *
 * @vco_mdccver: version of a mpool MDC content. It is the version
 * of the first binary that introduced that content semantic/format.
 * @vco_types: types used by this release (when writing MDC0-N content)
 *	The number of elements is vco_nbtypes. In increasing order.
 * @vco_nbtypes: how many different types are used by this release.
 * @vco_comment: comment about that version
 */
struct mdccver_info {
	struct omf_mdccver  vco_mdccver;
	uint8_t            *vco_types;
	uint8_t             vco_nbtypes;
	const char         *vco_comment;
};

/*
 * mpool MDC types used when MDC content is written at version 1.0.0.0.
 */
uint8_t mdccver_1_0_0_0_types[] = {
	OMF_MDR_OCREATE, OMF_MDR_OUPDATE, OMF_MDR_ODELETE, OMF_MDR_OIDCKPT,
	OMF_MDR_OERASE, OMF_MDR_MCCONFIG, OMF_MDR_MCSPARE, OMF_MDR_VERSION,
	OMF_MDR_MPCONFIG};


/*
 * mdccver_info mdcc_ver[] - table of versions of mpool MDCs content.
 *
 * Each time MDC content semantic/format changes (making it incompatible
 * with earlier binary versions) an entry is added in this table.
 * The entry at the end of the array (highest index) is the version placed
 * in the mpool MDC version record written to media when this binary writes
 * the mpool MDCs.
 * This entry is also the last mpool MDC content format/semantic that this
 * binary understands.
 *
 * Example:
 * - Initial binary 1.0.0.0 generates first ever MDCs content.
 *   There is one entry in the table with its vco_mdccver being 1.0.0.0.
 * - binary 1.0.0.1 is released and changes mpool MDC content semantic (for
 *   example chenge the meaning of media class enum). This release adds the
 *   entry 1.0.0.1 in this table.
 * - binary 1.0.1.0 is released and doesn't change MDCs content semantic/format,
 *   MDCs content generated by 1.0.1.0 binary is still compatible with a
 *   1.0.0.1 binary reading it.
 *   No entry is added in the table.
 * - binary 2.0.0.0 is released and it changes MDCs content semantic.
 *   A third entry is added in the table with its vco_mdccver being 2.0.0.0.
 */
struct mdccver_info mdcc_ver[] = {
	{{ {MDCCVER_MAJOR, MDCCVER_MINOR, MDCCVER_PATCH, MDCCVER_DEV} },
	mdccver_1_0_0_0_types, sizeof(mdccver_1_0_0_0_types),
	"Initial mpool MDCs content"},
};

#define _STR(x) #x
#define STR(x)  _STR(x)
static const char mpool_mdccver[] = "MPOOL_MDCCVER_" STR(MDCCVER_MAJOR) "." \
		STR(MDCCVER_MINOR) "." STR(MDCCVER_PATCH) "." STR(MDCCVER_DEV);

#pragma push_macro("upg_mdccver_latest")
#undef upg_mdccver_latest
struct omf_mdccver *
upg_mdccver_latest(void)
{
	return &(mdcc_ver[ARRAY_SIZE(mdcc_ver) - 1].vco_mdccver);
}
#pragma pop_macro("upg_mdccver_latest")

void upg_mdccver_latest2(struct omf_mdccver *mdccver)
{
	struct omf_mdccver *mdccver_latest;

	mdccver_latest = upg_mdccver_latest();
	*mdccver = *mdccver_latest;
}

const char *upg_mdccver_latest_comment(void)
{
	return mdcc_ver[ARRAY_SIZE(mdcc_ver) - 1].vco_comment;
}

const char *upg_mdccver_comment(struct omf_mdccver *mdccver)
{
	int i;

	for (i = 0; i < ARRAY_SIZE(mdcc_ver); i++)
		if (upg_ver_cmp(mdccver, "==", &(mdcc_ver[i].vco_mdccver)))
			return mdcc_ver[i].vco_comment;

	return NULL;
}

char *upg_mdccver2str(struct omf_mdccver *mdccver, char *buf, size_t sz)
{
	snprintf(buf, sz, "%u.%u.%u.%u", mdccver->mv_mdccver_major,
		 mdccver->mv_mdccver_minor, mdccver->mv_mdccver_patch,
		 mdccver->mv_mdccver_dev);

	return buf;
}

bool upg_ver_cmp(struct omf_mdccver *a, char *op, struct omf_mdccver *b)
{
	size_t cnt = ARRAY_SIZE(a->mv_mdccver);
	int    i;
	int    res = 0;

	for (i = 0; i < cnt; i++) {
		if (a->mv_mdccver[i] == b->mv_mdccver[i])
			continue;
		res = (a->mv_mdccver[i] > b->mv_mdccver[i]) ? 1 : -1;
		break;
	}

	if (((op[1] == '=') && (res == 0)) ||
	    ((op[0] == '>') && (res > 0)) ||
	    ((op[0] == '<') && (res < 0)))
		return true;

	return false;
}

bool
upg_ver_cmp2(
	struct omf_mdccver *a,
	char               *op,
	u16		    major,
	u16		    minor,
	u16		    patch,
	u16		    dev)
{
	struct omf_mdccver b;

	b.mv_mdccver_major = major;
	b.mv_mdccver_minor = minor;
	b.mv_mdccver_patch = patch;
	b.mv_mdccver_dev   = dev;

	return upg_ver_cmp(a, op, &b);
}
